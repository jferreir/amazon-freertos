/*
FreeRTOS+TCP V2.0.11
Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

 http://aws.amazon.com/freertos
 http://www.FreeRTOS.org
*/

/*
 * Copyright (c) 2015-2019, Infineon Technologies AG
 * All rights reserved.                        
 *                                             
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *                                                                              
 * To improve the quality of the software, users are encouraged to share 
 * modifications, enhancements or bug fixes with Infineon Technologies AG 
 * at XMCSupport@infineon.com.
 *****************************************************************************/

#include <limits.h>

/* FreeRTOS includes. */
#include "FreeRTOS.h"
#include "list.h"
#include "semphr.h"

/* FreeRTOS+TCP includes. */
#include "FreeRTOS_IP.h"
#include "FreeRTOS_IP_Private.h"
#include "NetworkBufferManagement.h"

#include "ethernet.h"
#include "NetworkInterface.h"

#define MAC_ADDR    ((uint64_t)configMAC_ADDR0 | \
                     ((uint64_t)configMAC_ADDR1 << 8) | \
                     ((uint64_t)configMAC_ADDR2 << 16) | \
                     ((uint64_t)configMAC_ADDR3 << 24) | \
                     ((uint64_t)configMAC_ADDR4 << 32) | \
                     ((uint64_t)configMAC_ADDR5 << 40))

#ifndef configNUM_RX_DESCRIPTORS
#error "ERROR: Define configNUM_RX_DESCRIPTORS in your FreeRTOSIPConfig.h"
#endif

#ifndef configNUM_TX_DESCRIPTORS
#error "ERROR: define configNUM_TX_DESCRIPTORS in your FreeRTOSIPConfig.h"
#endif


#if defined(__ICCARM__)
#pragma data_alignment=4
static XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] @ ".dram";
#pragma data_alignment=4
static XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] @ ".dram";
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
#pragma data_alignment=4
static uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] @ ".dram";
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
#pragma data_alignment=4
static uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] @ ".dram";
#endif
#elif defined(__CC_ARM) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] __attribute__((section ("RW_IRAM1")));
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] __attribute__((section ("RW_IRAM1")));
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("RW_IRAM1")));
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("RW_IRAM1")));
#endif
#elif defined(__GNUC__)
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_rx_desc[configNUM_RX_DESCRIPTORS] __attribute__((section ("ETH_RAM")));
static __ALIGNED(4) XMC_ETH_MAC_DMA_DESC_t eth_tx_desc[configNUM_TX_DESCRIPTORS] __attribute__((section ("ETH_RAM")));
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_rx_buf[configNUM_RX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("ETH_RAM")));
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
static __ALIGNED(4) uint8_t eth_tx_buf[configNUM_TX_DESCRIPTORS][XMC_ETH_MAC_BUF_SIZE] __attribute__((section ("ETH_RAM")));
#endif
#endif


/* If ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES is set to 1, then the Ethernet
driver will filter incoming packets and only pass the stack those packets it
considers need processing. */
#if( ipconfigETHERNET_DRIVER_FILTERS_FRAME_TYPES == 0 )
#define ipCONSIDER_FRAME_FOR_PROCESSING( pucEthernetBuffer ) eProcessBuffer
#else
#define ipCONSIDER_FRAME_FOR_PROCESSING( pucEthernetBuffer ) eConsiderFrameForProcessing( ( pucEthernetBuffer ) )
#endif

static TaskHandle_t netif_task_handler = NULL;
static XMC_ETH_LINK_STATUS_t link_status = XMC_ETH_LINK_STATUS_DOWN;

/* xTXDescriptorSemaphore is a counting semaphore with
   a maximum count of TX_DESC_CNT, which is the number of
	DMA TX descriptors. */
static SemaphoreHandle_t xTXDescriptorSemaphore = NULL;

static uint32_t ulTxDescriptorToClear = 0;

void ETH0_0_IRQHandler(void)
{
  BaseType_t xHigherPriorityTaskWoken;
  uint32_t ulStatusRegister;

  ulStatusRegister = XMC_ETH_MAC_GetEventStatus(&eth_mac);
  XMC_ETH_MAC_ClearEventStatus(&eth_mac, ulStatusRegister);

  if (netif_task_handler != 0)
  {
    /* xHigherPriorityTaskWoken must be initialised to pdFALSE.  If calling
	   xTaskNotifyFromISR() unblocks the handling task, and the priority of
	   the handling task is higher than the priority of the currently running task,
	   then xHigherPriorityTaskWoken will automatically get set to pdTRUE. */
	xHigherPriorityTaskWoken = pdFALSE;

	/* Unblock the handling task so the task can perform any processing necessitated
	    by the interrupt.  xHandlingTask is the task's handle, which was obtained
	    when the task was created.  The handling task's notification value
	    is bitwise ORed with the interrupt status - ensuring bits that are already
	    set are not overwritten. */
	xTaskNotifyFromISR(netif_task_handler, ulStatusRegister, eSetBits, &xHigherPriorityTaskWoken );

	/* Force a context switch if xHigherPriorityTaskWoken is now set to pdTRUE.
	    The macro used to do this is dependent on the port and may be called
	    portEND_SWITCHING_ISR. */
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
  }
}

#if (ipconfigZERO_COPY_RX_DRIVER == 0)
static void prvNetworkInterfaceInput(void)
{
  uint32_t xReceivedLength;
  uint8_t *pucBuffer;
  NetworkBufferDescriptor_t *pxDescriptor;
  const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );
  xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };

  xReceivedLength = XMC_ETH_MAC_GetRxFrameSize(&eth_mac);

  if ((xReceivedLength > 0) && (xReceivedLength <= XMC_ETH_MAC_BUF_SIZE))
  {
    pucBuffer = XMC_ETH_MAC_GetRxBuffer(&eth_mac);

    if (ipCONSIDER_FRAME_FOR_PROCESSING(pucBuffer))
    {
	  pxDescriptor = pxGetNetworkBufferWithDescriptor(xReceivedLength, xDescriptorWaitTime);
	  if (pxDescriptor != NULL)
	  {
 		memcpy(pxDescriptor->pucEthernetBuffer, pucBuffer, xReceivedLength);

		pxDescriptor->xDataLength = xReceivedLength;
		xRxEvent.pvData = ( void * )pxDescriptor;

		/* Pass the data to the TCP/IP task for processing. */
		if (xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE)
		{
		  /* Could not send the descriptor into the TCP/IP stack, it must be released. */
		  vReleaseNetworkBufferAndDescriptor(pxDescriptor);
		  iptraceETHERNET_RX_EVENT_LOST();
		}
		else
		{
		  iptraceNETWORK_INTERFACE_RECEIVE();
		}
      }
    }
  }

  XMC_ETH_MAC_ReturnRxDescriptor(&eth_mac);
  XMC_ETH_MAC_ResumeRx(&eth_mac);

}
#else
static void prvNetworkInterfaceInput(void)
{
  uint32_t xReceivedLength;
  uint8_t *pucBuffer;
  NetworkBufferDescriptor_t *pxDescriptor;
  const TickType_t xDescriptorWaitTime = pdMS_TO_TICKS( 250 );
  xIPStackEvent_t xRxEvent = { eNetworkRxEvent, NULL };

  xReceivedLength = XMC_ETH_MAC_GetRxFrameSize(&eth_mac);
  if ((xReceivedLength > 0) && (xReceivedLength <= ipTOTAL_ETHERNET_FRAME_SIZE))
  {
	pucBuffer = XMC_ETH_MAC_GetRxBuffer(&eth_mac);

	if (ipCONSIDER_FRAME_FOR_PROCESSING(pucBuffer))
	{
	  /* Allocate a new network buffer descriptor that references an Ethernet
		 frame large enough to hold the maximum network packet size (as defined
		 in the FreeRTOSIPConfig.h header file). */
	  pxDescriptor = pxGetNetworkBufferWithDescriptor(ipTOTAL_ETHERNET_FRAME_SIZE, xDescriptorWaitTime);
	  if (pxDescriptor != NULL)
	  {
		XMC_ETH_MAC_SetRxBuffer(&eth_mac, pxDescriptor->pucEthernetBuffer);

		pxDescriptor->pucEthernetBuffer = pucBuffer;
		pxDescriptor->xDataLength = xReceivedLength;

		*( ( NetworkBufferDescriptor_t ** )
		         ( pxDescriptor->pucEthernetBuffer - ipBUFFER_PADDING ) ) = pxDescriptor;

		/*
		 * The network buffer descriptor now points to the Ethernet buffer that
		 * contains the received data, and the Ethernet DMA descriptor now points
		 * to a newly allocated (and empty) Ethernet buffer ready to receive more
		 * data.  No data was copied.  Only pointers to data were swapped.
		 */

		xRxEvent.pvData = ( void * )pxDescriptor;

		/* Pass the data to the TCP/IP task for processing. */
		if (xSendEventStructToIPTask( &xRxEvent, xDescriptorWaitTime ) == pdFALSE)
		{
		  /* Could not send the descriptor into the TCP/IP stack, it must be released. */
		  vReleaseNetworkBufferAndDescriptor(pxDescriptor);
		  iptraceETHERNET_RX_EVENT_LOST();
		}
		else
		{
		  iptraceNETWORK_INTERFACE_RECEIVE();
		}
      }
	}
  }

  XMC_ETH_MAC_ReturnRxDescriptor(&eth_mac);
  XMC_ETH_MAC_ResumeRx(&eth_mac);
}
#endif

static void vClearTXBuffers()
{
  size_t uxCount = (( UBaseType_t)configNUM_TX_DESCRIPTORS) - uxSemaphoreGetCount(xTXDescriptorSemaphore);

  /* This function is called after a TX-completion interrupt.
	 It will release each Network Buffer used in xNetworkInterfaceOutput().
  	 'uxCount' represents the number of descriptors given to DMA for transmission.
	 After sending a packet, the DMA will clear the 'ETH_DMATXDESC_OWN' bit. */
  while ((uxCount > 0) && (XMC_ETH_MAC_IsTxDescriptorOwnedByDmaEx(&eth_mac, ulTxDescriptorToClear) == pdFALSE))
  {
#if( ipconfigZERO_COPY_TX_DRIVER != 0 )
	uint8_t *ucPayLoad = XMC_ETH_MAC_GetTxBufferEx(&eth_mac, ulTxDescriptorToClear);
	if( ucPayLoad != NULL )
	{
      NetworkBufferDescriptor_t *pxDescriptor = pxPacketBuffer_to_NetworkBuffer(ucPayLoad);
      if (pxDescriptor != NULL)
      {
	    vReleaseNetworkBufferAndDescriptor(pxDescriptor);
      }
      XMC_ETH_MAC_SetTxBufferEx(&eth_mac, ulTxDescriptorToClear, 0);
	}
#endif

	/* Move onto the next descriptor, wrapping if necessary. */
	ulTxDescriptorToClear++;
	if (ulTxDescriptorToClear >= configNUM_TX_DESCRIPTORS )
	{
	  ulTxDescriptorToClear = 0;
	}

	uxCount--;

	/* Tell the counting semaphore that one more TX descriptor is available. */
	xSemaphoreGive( xTXDescriptorSemaphore );
  }
}

static void set_link_up(void)
{
  while (XMC_ETH_PHY_IsAutonegotiationCompleted(&eth_mac, ETH_PHY_ADDR) == false);

  XMC_ETH_LINK_SPEED_t speed = XMC_ETH_PHY_GetLinkSpeed(&eth_mac, ETH_PHY_ADDR);
  XMC_ETH_LINK_DUPLEX_t duplex = XMC_ETH_PHY_GetLinkDuplex(&eth_mac, ETH_PHY_ADDR);

  XMC_ETH_MAC_SetLink(&eth_mac, speed, duplex);

  /* Enable ethernet interrupts */
  XMC_ETH_MAC_EnableEvent(&eth_mac, (uint32_t)(XMC_ETH_MAC_EVENT_RECEIVE | XMC_ETH_MAC_EVENT_TRANSMIT));

  NVIC_SetPriority(ETH0_0_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(), 62U, 0U));
  NVIC_ClearPendingIRQ(ETH0_0_IRQn);
  NVIC_EnableIRQ(ETH0_0_IRQn);

  XMC_ETH_MAC_EnableTx(&eth_mac);
  XMC_ETH_MAC_EnableRx(&eth_mac);

  link_status = XMC_ETH_LINK_STATUS_UP;
}

static void set_link_down(void)
{
  XMC_ETH_MAC_DisableEvent(&eth_mac, (uint32_t)(XMC_ETH_MAC_EVENT_RECEIVE | XMC_ETH_MAC_EVENT_TRANSMIT));
  NVIC_DisableIRQ(ETH0_0_IRQn);

  XMC_ETH_MAC_DisableTx(&eth_mac);
  XMC_ETH_MAC_DisableRx(&eth_mac);

  link_status = XMC_ETH_LINK_STATUS_DOWN;
}

static void netif_task(void *arg)
{
  (void)arg;
  uint32_t ulInterruptStatus;

  while (1)
  {
    /* Block indefinitely (without a timeout, so no need to check the function's
	   return value) to wait for a notification.  NOTE!  Real applications
	   should not block indefinitely, but instead time out occasionally in order
	   to handle error conditions that may prevent the interrupt from sending
	   any more notifications. */
	 xTaskNotifyWait(0,                  /* Don't clear any bits on entry. */
	                 UINT_MAX,           /* Clear all bits on exit. */
	                 &ulInterruptStatus, /* Receives the notification value. */
	                 portMAX_DELAY);     /* Block indefinitely. */

	if ((ulInterruptStatus & XMC_ETH_MAC_EVENT_RECEIVE) != 0)
    {
      /* Go through the application owned descriptors */
      while (XMC_ETH_MAC_IsRxDescriptorOwnedByDma(&eth_mac) == pdFALSE)
      {
		prvNetworkInterfaceInput();
      }
    }

	if ((ulInterruptStatus & XMC_ETH_MAC_EVENT_TRANSMIT) != 0 )
	{
	  /* Check if DMA packets have been delivered. */
      vClearTXBuffers();
	}
  }
}


BaseType_t xNetworkInterfaceInitialise( void )
{
  if (netif_task_handler == NULL)
  {
	if( xTXDescriptorSemaphore == NULL )
	{
	  xTXDescriptorSemaphore = xSemaphoreCreateCounting( ( UBaseType_t ) configNUM_TX_DESCRIPTORS, ( UBaseType_t ) configNUM_TX_DESCRIPTORS );
	  configASSERT( xTXDescriptorSemaphore );
	}

    /* Initialize network interfaces */
    if (xTaskCreate(netif_task, "netif_task", configMINIMAL_STACK_SIZE, NULL, configMAX_PRIORITIES - 1, &netif_task_handler) != pdPASS)
    {
      return pdFALSE;
    }

    // Configure ethernet port
	eth_mac.rx_desc = eth_rx_desc;
	eth_mac.tx_desc = eth_tx_desc;
#if( ipconfigZERO_COPY_RX_DRIVER == 0 )
	eth_mac.rx_buf = &eth_rx_buf[0][0];
#else
	eth_mac.rx_buf = NULL;
#endif
#if( ipconfigZERO_COPY_TX_DRIVER == 0 )
	eth_mac.tx_buf = &eth_tx_buf[0][0];
#else
	eth_mac.tx_buf = NULL;
#endif
	eth_mac.num_rx_buf = configNUM_RX_DESCRIPTORS;
	eth_mac.num_tx_buf = configNUM_TX_DESCRIPTORS;
	eth_mac.address = MAC_ADDR;

    XMC_ETH_MAC_InitEx(&eth_mac);
	XMC_ETH_MAC_DisableJumboFrame(&eth_mac);
	XMC_ETH_MAC_SetAddress(&eth_mac, eth_mac.address);

#if( ipconfigZERO_COPY_RX_DRIVER != 0 )
	for (int32_t index = 0; index < configNUM_RX_DESCRIPTORS; ++index)
	{
      NetworkBufferDescriptor_t *pxDescriptor = pxGetNetworkBufferWithDescriptor( ipTOTAL_ETHERNET_FRAME_SIZE, 0 );
	  /* During start-up there should be enough Network Buffers available,
		 so it is safe to use configASSERT().
		 In case this assert fails, please check: configNUM_RX_DESCRIPTORS,
		 ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS, and in case BufferAllocation_2.c
		 is included, check the amount of available heap. */
	  configASSERT( pxDescriptor != NULL );

	  XMC_ETH_MAC_SetRxBufferEx(&eth_mac, index, pxDescriptor->pucEthernetBuffer);
	}
#endif

  }

  if (xGetPhyLinkStatus() == pdFALSE)
  {
    if (link_status != XMC_ETH_LINK_STATUS_DOWN)
    {
      set_link_down();
      return pdFALSE;
    }
  }
  else
  {
    if (link_status != XMC_ETH_LINK_STATUS_UP)
    {
      set_link_up();

      /* When returning non-zero, the stack will become active and
         start DHCP (if configured) */
	    return pdPASS;
    }
  }

  return pdFALSE;
}


#if (ipconfigZERO_COPY_TX_DRIVER == 0)
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxNetworkBuffer, BaseType_t xReleaseAfterSend )
{
  uint8_t *buffer;
  const TickType_t xBlockTimeTicks = pdMS_TO_TICKS(50u);
  BaseType_t xReturn = pdFAIL;

  do
  {
    if (pxNetworkBuffer->xDataLength > XMC_ETH_MAC_BUF_SIZE)
    {
      break;
    }

	if (xTXDescriptorSemaphore == NULL)
	{
		break;
	}

    if (xSemaphoreTake(xTXDescriptorSemaphore, xBlockTimeTicks) != pdPASS)
    {
  	  /* Time-out waiting for a free TX descriptor. */
	  break;
    }

	/* If the descriptor is still owned by the DMA it can't be used. */
    if (XMC_ETH_MAC_IsTxDescriptorOwnedByDma(&eth_mac))
    {
  	  /* The semaphore was taken, the TX DMA-descriptor is still not available.
		 Actually that should not occur, the 'TDES_OWN' was already confirmed low in vClearTXBuffers(). */
	  xSemaphoreGive( xTXDescriptorSemaphore );
    }
    else
    {
      buffer = XMC_ETH_MAC_GetTxBuffer(&eth_mac);
      memcpy((void *)buffer, pxNetworkBuffer->pucEthernetBuffer, pxNetworkBuffer->xDataLength);

      XMC_ETH_MAC_SetTxBufferSize(&eth_mac, pxNetworkBuffer->xDataLength);
      XMC_ETH_MAC_ReturnTxDescriptor(&eth_mac);
      XMC_ETH_MAC_ResumeTx(&eth_mac);

      iptraceNETWORK_INTERFACE_TRANSMIT();

      xReturn = pdPASS;
    }
  } while( 0 );


  /* The buffer has been sent so can be released. */
  if (xReleaseAfterSend != pdFALSE)
  {
	vReleaseNetworkBufferAndDescriptor( pxNetworkBuffer );
  }

  return xReturn;
}

#else
BaseType_t xNetworkInterfaceOutput( NetworkBufferDescriptor_t * const pxDescriptor, BaseType_t xReleaseAfterSend )
{
  (void)xReleaseAfterSend;
  const TickType_t xBlockTimeTicks = pdMS_TO_TICKS(50u);
  BaseType_t xReturn = pdFAIL;

  do
  {
	if (xTXDescriptorSemaphore == NULL)
	{
  	  break;
	}

    if (xSemaphoreTake(xTXDescriptorSemaphore, xBlockTimeTicks) != pdPASS)
    {
   	  /* Time-out waiting for a free TX descriptor. */
      break;
    }
	/* If the descriptor is still owned by the DMA it can't be used. */
    if (XMC_ETH_MAC_IsTxDescriptorOwnedByDma(&eth_mac))
    {
  	  /* The semaphore was taken, the TX DMA-descriptor is still not available.
		 Actually that should not occur, the 'TDES_OWN' was already confirmed low in vClearTXBuffers(). */
	  xSemaphoreGive( xTXDescriptorSemaphore );
    }
    else
    {
      XMC_ETH_MAC_SetTxBuffer(&eth_mac, pxDescriptor->pucEthernetBuffer);
      XMC_ETH_MAC_SetTxBufferSize(&eth_mac, pxDescriptor->xDataLength);

      XMC_ETH_MAC_ReturnTxDescriptor(&eth_mac);
      XMC_ETH_MAC_ResumeTx(&eth_mac);

      iptraceNETWORK_INTERFACE_TRANSMIT();

      xReturn = pdPASS;

    }
  } while(0);

  return xReturn;
}

#endif

/* First statically allocate the buffers, ensuring an additional ipBUFFER_PADDING
bytes are allocated to each buffer.  This example makes no effort to align
the start of the buffers, but most hardware will have an alignment requirement.
If an alignment is required then the size of each buffer must be adjusted to
ensure it also ends on an alignment boundary.  Below shows an example assuming
the buffers must also end on an 8-byte boundary. */
#define BUFFER_SIZE ( ipTOTAL_ETHERNET_FRAME_SIZE + ipBUFFER_PADDING )
#define BUFFER_SIZE_ROUNDED_UP ( ( BUFFER_SIZE + 7 ) & ~0x07UL )
#if defined(__ICCARM__)
#pragma data_alignment=4
static uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ] @ ".dram";
#elif defined(__CC_ARM) || (defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050))
static __ALIGNED(4) uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ] __attribute__((section ("RW_IRAM1")));
#elif defined(__GNUC__)
static __ALIGNED(4) uint8_t ucBuffers[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ][ BUFFER_SIZE_ROUNDED_UP ]  __attribute__((section ("ETH_RAM")));
#endif

/* Next provide the vNetworkInterfaceAllocateRAMToBuffers() function, which
simply fills in the pucEthernetBuffer member of each descriptor. */
void vNetworkInterfaceAllocateRAMToBuffers(
    NetworkBufferDescriptor_t pxDescriptor[ ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS ] )
{
  for( BaseType_t x = 0; x < ipconfigNUM_NETWORK_BUFFER_DESCRIPTORS; ++x )
  {
    /* pucEthernetBuffer is set to point ipBUFFER_PADDING bytes in from the
       beginning of the allocated buffer. */
	pxDescriptor[ x ].pucEthernetBuffer = &( ucBuffers[ x ][ ipBUFFER_PADDING ] );

    /* The following line is also required, but will not be required in
       future versions. */
    *( ( uint32_t * ) &ucBuffers[ x ][ 0 ] ) = ( uint32_t ) &( pxDescriptor[ x ] );
  }
}

BaseType_t xGetPhyLinkStatus(void)
{
  if (XMC_ETH_PHY_GetLinkStatus(&eth_mac, ETH_PHY_ADDR) != XMC_ETH_LINK_STATUS_DOWN)
  {
	return pdTRUE;
  }

  return pdFALSE;
}

